---
layout:     post
title:      "[BOJ] 12015 가장 긴 증가하는 부분 수열 2 - C++"
subtitle:   " \"이분탐색\""
date:       2021-07-02 11:40:00
author:     "Yongmin"
header-img: "img/ABC.jpg"
catalog: true
tags:
    - BOJ
    - C++
  
---

# 문제
[가장 긴 증가하는 부분 수열 2](https://www.acmicpc.net/problem/12015)

# 풀이
기존에 DP로 풀었던 문제와 같은 문제이다. 그러나, 같은 알고리즘으로 하면 testcase의 arr.size()가 커져서 시간초과가 나는 문제이다.
문제의 알고리즘은 다음과 같다.
1. 주어진 testcase의 첫번째 값을 result vector에 넣는다.
2. iteration으로 N번째까지 조건에 부합하는지 안하는지 확인한다.
2-1. testcase 수열의 i번째 값이 result 벡터의 맨 마지막 값보다 크면 result vector에 그 값을 push_back한다.
2-2. result의 맨 마지막 값보다 작으면 그 수보다 큰 값이 가장 먼저 나오는 index에 그 값으로 대체한다. (이분 탐색 사용)
3. result.size()로 정답 출력한다.

# 소스 코드

```c++
#include <iostream>
#include <vector>
using namespace std;

int binarysearch(vector<int> &a, int num){
    int ans = 0;
    int left = 0;
    int right = a.size()-1;
    
    while(left<=right){
        int mid = (left+right)/2;
        
        if(a[mid] >= num){
            ans = mid;
            right = mid - 1;
        }
        else left = mid + 1;
    }

    return ans;
}

int main(){
    int N;
    scanf("%d", &N);
    
    vector<int> arr(N);
    for(int i = 0 ; i<N; i++){
        scanf("%d", &arr[i]);
    }
    
    vector<int> result;
    result.push_back(arr[0]);
    
    for(int i = 1; i<N; i++){
        if(result.back() < arr[i]) result.push_back(arr[i]);
        else{
            int idx = binarysearch(result, arr[i]);
            result[idx] = arr[i];
        }
    }
    
    printf("%d\n", result.size());
}
```

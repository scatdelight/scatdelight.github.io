---
layout:     post
title:      "[BOJ] 7576번 토마토 - C++"
subtitle:   " \"DFS와 BFS\""
date:       2021-07-20 11:40:00
author:     "Yongmin"
header-img: "img/gyul.jpg"
catalog: true
tags:
    - BOJ
    - C++
  
---

# 문제
[토마토](https://www.acmicpc.net/problem/7576)

# 풀이
최소날짜를 구하는 문제로, BFS를 이용하여 풀이하였다. 처음 주어진 map에서 1인 지점의 좌표들을 먼저 넣음으로써 시작하였다. 그 이후, 상하좌우에 map이 0이며 방문하지 않으면 큐에 넣는 식을 반복하였다.
-1의 경우는 미리 visit을 했다고 셋팅하여 -1을 밟지 못하게 만들어놨다. check함수를 이용하여, 마지막에 작성된 check함수의 값 -1로 정답을 도출해냈다.

# 소스 코드
```c++
#include <iostream>
#include <vector>
#include <climits>
#include <queue>

using namespace std;

vector<vector<int>> map(1001, vector<int> (1001));
vector<vector<int>> check(1001, vector<int> (1001));
vector<vector<bool>> visit(1001, vector<bool> (1001));



int N, M, cnt;
int dx[4] = {0, 0, -1, 1};
int dy[4] = {1, -1, 0, 0};

void bfs(){
    queue<pair<int, int>> q;
    
    for(int i = 1; i<=M; i++){
        for(int j = 1; j<=N; j++){
            if(map[i][j] == 1){
                q.push(make_pair(i, j));
                check[i][j] = 1;
                visit[i][j] = true;
            }
            if(map[i][j] == -1){
                check[i][j] = -1;
                visit[i][j] = true;
            }
        }
    }
    
    
    while(!q.empty()){
        cnt++;
        int y = q.front().first;
        int x = q.front().second;
        q.pop();
        
        for(int i = 0; i<4; i++){
            if(y+dy[i] <= M && y+dy[i] >= 1 && x+dx[i] <= N && x+dx[i] >=1 && map[y+dy[i]][x+dx[i]] == 0 && visit[y+dy[i]][x+dx[i]] == false){
                check[y+dy[i]][x+dx[i]] = check[y][x] + 1;
                q.push(make_pair(y+dy[i], x+dx[i]));
                visit[y+dy[i]][x+dx[i]] = true;
            }
        }
    }
    
}

int main(){
    
    scanf("%d %d", &N, &M);
    
    for(int i = 1; i<=M; i++){
        for(int j = 1; j<=N; j++){
            scanf("%d", &map[i][j]);
        }
    }
    
    bfs();
    
    for(int i = 1; i<=M; i++){
        for(int j = 1; j<=N; j++){
            if(check[i][j] == 0){
                printf("%d\n", -1);
                return 0;
            }
        }
    }
    
    int result = 0;
    for(int i = 1; i<=M; i++){
        for(int j = 1; j<=N; j++){
            result = max(result, check[i][j]);
        }
    }
    
    printf("%d\n", result-1);
    
}
```

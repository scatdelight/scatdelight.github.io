---
layout:     post
title:      "[BOJ] 11657번 타임머신 - C++"
subtitle:   " \"최단경로\""
date:       2021-07-26 09:54:00
author:     "Yongmin"
header-img: "img/gyul.jpg"
catalog: true
tags:
    - BOJ
    - C++
  
---

# 문제
[타임머신](https://www.acmicpc.net/problem/11657)

# 풀이

벨만-포드 알고리즘에 대한 문제이다. 다익스트라는 가중치가 모두 양수일때만 사용할 수 있는 알고리즘이다. 그렇기 때문에 문제에서 제시된 음수 가중치가 있는 경우에는 시간복잡도 O(|V|*|E|)인 벨만-포드 알고리즘을 사용해야한다.
벨만포드 알고리즘은 정점 갯수 N이 주어졌을 때, N-1번동안 모든 간선을 이동할 때마다 최저값을 갱신해나가는 것을 시작으로 하여, 그 이후 한번 더 갱신을 시도했을 때,
값이 바뀌는 경우가 있다면, 그것은 음의 사이클(=계속해서 무한대로 -로 다가가는 경우)라고 하고, 갱신이 되지 않는다면 음의 가중치가 있을 때의 최저값을 보장한다. 

# 소스 코드

```c++
#include <iostream>
#include <queue>
#include <vector>
#include <climits>
#include <algorithm>

using namespace std;

int testcase, n, m, t, s, g, h;
int dist[2001];
vector<pair<int, int>> map[2001];
vector<int> dest(101);
vector<int> result;

int dijkstra(int start, int end){
    for(int i = 1; i<=n; i++){
        dist[i] = INT_MAX;
    }
    
    dist[start] = 0;
    
    priority_queue<pair<int, int>> q;
    
    q.push(make_pair(0, start));
    
    while(!q.empty()){
        int cost = -q.top().first;
        int now = q.top().second;
        
        q.pop();
        
        for(int i = 0; i<map[now].size(); i++){
            int ncost = map[now][i].second;
            int next = map[now][i].first;
            
            if(dist[next] > cost + ncost){
                dist[next] = cost + ncost;
                q.push(make_pair(-dist[next], next));
            }
        }
    }
    return dist[end];
}

int main(){
    scanf("%d", &testcase);
    
    for(int i = 0 ; i<testcase; i++){
        scanf("%d %d %d", &n, &m, &t);
        scanf("%d %d %d", &s, &g, &h); // s : 시작점, g, h : 반드시 거쳐야 하는 지점
        
        for(int i = 0; i< 2001; i++){
            map[i].clear();
        }
        
        dest.clear();
        
        result.clear();
        
        for(int i = 0; i<m; i++){
            int from, to, value;
            scanf("%d %d %d", &from, &to, &value);
            map[from].push_back(make_pair(to, value));
            map[to].push_back(make_pair(from, value));
        }
        
        for(int i = 0; i<t; i++){
            scanf("%d", &dest[i]);
        }
        
        for(int i = 0; i<t; i++){
            int route1;
            int a1 = dijkstra(s, g);
            int a2 = dijkstra(g, h);
            int a3 = dijkstra(h, dest[i]);
            if(a1 == INT_MAX || a2 == INT_MAX || a3 == INT_MAX) route1 = -1;
            else route1 = a1+a2+a3;
            
            //printf("%d %d %d\n", a1, a2, a3);
            
            int route2;
            int b1 = dijkstra(s, h);
            int b2 = dijkstra(h, g);
            int b3 = dijkstra(g, dest[i]);
            if(b1 == INT_MAX || b2 == INT_MAX || b3 == INT_MAX) route2 = -1;
            else route2 = b1+b2+b3;
            
            //printf("%d %d %d\n", b1, b2, b3);
            
            int route3 = dijkstra(s, dest[i]);
            
            //printf("route3 = %d\n", route3);
            
            if(route1 == route3 || route2 == route3) result.push_back(dest[i]);
            
        }
        
        sort(result.begin(), result.end());
        
        for(int i = 0; i<result.size(); i++){
            printf("%d ", result[i]);
        }
        
        printf("\n");
    
    }
}
```

---
layout:     post
title:      "[BOJ] 2098번 외판원 순회 - C++"
subtitle:   " \"동적 계획법 3\""
date:       2021-09-14 14:39:00
author:     "Yongmin"
header-img: "img/gyul.jpg"
catalog: true
tags:
    - BOJ
    - C++
  
---

# 문제
[외판원 순회](https://www.acmicpc.net/problem/2098)

# 풀이

비트마스크 활용 문제이다. 비트마스크 + DP + 메모이제이션을 이용해야 한다. 현재 방문되있는 node인 current 인자와 현재 무슨 도시들을 방문했는지 정보를 담고 있는 bitmask 인자를 이용하여 dp[current][bitmask] 배열을 이용한다. dfs를 이용하여 시티들을 차례로 방문하여 완전탐색을 진행한다. 이때, 이미 그 값이 정해져있다면 바로 그 값을 return(메모이제이션)을 해주고, 그렇지 않다면 차례대로 도시들을 방문하여 가장 작은 값으로 갱신하도록 한다.


# 소스 코드

```c++
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <cstring>

#define INF 987654321

using namespace std;

int N;

int testcase[17][17];
int dp[17][1<<17];

int TSP(int start, int bitmask){

    int &ret = dp[start][bitmask];
    
    if(ret != -1){
        return ret;
    }
    // 메모이제이션
    
    if(bitmask == ((1<<N) - 1)){ // 모든 도시를 방문했다면, 다시 원래(0번 도시)로 돌아와야한다.
        if(testcase[start][0] == 0) return INF; // 마지막 도시에서 0번 도시로 못간다면, 그 답은 아니므로 INF
        else return testcase[start][0]; // 마지막 도시에서 0번 도시로 갈 수 있다면, 소모되는 비용을 return
    }
    
    ret = INF;
    
    for(int i = 0 ; i<N; i++){
        if(testcase[start][i] == 0) continue;
        if(!(bitmask & (1<<i))){
            ret = min(ret, TSP(i, bitmask|(1<<i)) + testcase[start][i]);
        }
    }

    return ret;
}

int main(){
    
    scanf("%d", &N);
        
    for(int i = 0 ; i<N; i++){
        for(int j = 0 ; j<N; j++){
            scanf("%d", &testcase[i][j]);
        }
    }
    
    // *** 입력 완료 ***
    
    
    memset(dp, -1, sizeof(dp));
    
    // dp[1][0010] --> 현재 1번 도시에 있으며, 현재 1번 도시만 방문한 상태일 때, 최소비용이 저장되있음.
    
    printf("%d\n", TSP(0, 1));

}
```
